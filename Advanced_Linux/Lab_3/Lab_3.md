# Лабораторная работа №3. Тема: "Дискреционное управление доступом"
Цель работы
----------
научиться поиску файлов по правам доступа;

получить навык и понимание как менять дискреционные права доступа;

разобраться в терминологии данной настройки;

получить навык настройки общих каталогов для групп пользователей, использование SGID, SUID, Sticky-bit;

создать общие каталоги для пользователей с использованием файловых списков доступа;

познакомиться с атрибутов append.

Оборудование, ПО:
----------

Виртуальная машина или компьютер под управлением ОС AstraLinux 1.7 в любом уровне защищенности.

Ход работы:
----------

Умение пользоваться инструментами фильтрации и поиска текста в Linux - крайне полезный и нужный навык для инженера, который работает с данной ОС.
Не стоит полагать, что этот навык нужен только для специалистов, которые много работают с документами.
Поиск логов, создание скриптов для автоматизации, быстрые административные задачи по смене ярлыков, поиск зависшего процесса и многое другое возможно с применением этих инструментов!


Введем новый термин - **Регулярные выражения**

# Это нужно знать!

---------------

Регулярные выражения - это шаблон, который соответсвует сразу нескольким наборам строк. Шаблон состоит из операторов, используя символы и метасимволы (о метасимволах поговорим подробнее позднее)


---------------

Начнем с первого инструмента работы с текстом - утилита Grep

---------------

 **grep - утилита командной строки, которая находит строку из файлов**

---------------

Формат работы с grep следующий:

grep [ПАРАМЕТР] искомая строка [ФАЙЛ]

Начнем с простого:

```console
$  grep processor /proc/cpuinfo
```

В ответ, вам вернётся номера процессоров (каждого ядра отдельно).

Например

```console
proсessor : 0
processor : 1
```

По умолчанию, grep регистрозависимый, если запрос сформирован с прописных букв, то записи со строчными буквами отображены не будут.

Проверим, что будет если мы введем не полностью слово "processor", а например лишь его часть - слово "proc"

```console
$  grep proc /proc/cpuinfo
```

Результат тот же, значит делаем вывод - grep, при стандартном использовании без ключей, ищет строку в составе текста и слова.

А что, если нам нужно найти именно слово "proc"? Как избежать "однокоренные" значения?

Воспользуемся параметром "-w"

```console
$  grep -w "proc" /proc/cpuinfo
```

Как можно заметить, ответа не поступило! В файле /proc/cpuinfo нет строк "proc"

Давайте проверим на другом примере, выполним 'grep' на /proc/cpuinfo. Поищем слово "cpu".

```console
$  grep cpu /proc/cpuinfo
```

Как можно заметить, в этом случае, мы получили много строк, где слово "cpu" встречается отдельно, а также в составе других слов.

![Картинка](./Screen1.png)

Проверим с ключом -w

![Картинка](./Screen2.png)

Теперь, множество строк пропали, указав вам только значения конкретных слов "cpu"

А что, например, если нам нужно найти строку, которая начинается на шаблонное слово, но продолжается и оканчивается на различные символы?

Попробуем найти все строчки, которые начинаются на слово "cpu"

Обратите внимание, мы применили метасимволы. К ним относятся: ".", "\", "$", "*", "[", "]", "^", "&".

```console
$  grep 'cpu\>' /proc/cpuinfo
```

![Картинка](./Screen3.png)


Благодарю за чтение и успехов вам в обучении!


# Дополнительная информация:
1) Шпаргалки как работать с awk [Ссылка](https://likegeeks.com/awk-command/)
2) Шпаргалки как работать с grep[Ссылка](https://digitology.tech/posts/shpargalka-po-gnu-grep/)
3) Шпаргалки как работать с sed [Ссылка](https://soft-setup.ru/shpargalka-po-sed-v-linux-s-primerami/)
