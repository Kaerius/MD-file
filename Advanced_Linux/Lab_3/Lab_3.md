# Лабораторная работа №3. Тема: "Дискреционное управление доступом"
Цель работы
----------
научиться поиску файлов по правам доступа;

получить навык и понимание как менять расширенные дискреционные права доступа ;

разобраться в терминологии данной настройки;

получить навык настройки общих каталогов для групп пользователей, использование SGID, SUID, Sticky-bit;

создать общие каталоги для пользователей с использованием файловых списков доступа;

познакомиться с атрибутом append.

Оборудование, ПО:
----------

Виртуальная машина или компьютер под управлением ОС AstraLinux 1.7 в любом уровне защищенности.

Ход работы:
----------

# Расширенные права доступа (Extended POSIX ACL)
При прохождении базового курса вы уже знакомились с минимимальным функционалом настройки прав доступа, или как часто можно встретить в англоязычной терминологии - Minimal POSIX ACL.


Напомним, как эти права доступа выглядят

![Картинка](./Screen1.png)


Также Minimal ACL имеют числовое представление (Numeric Notation) в виде трех восьмеричных чисел. Эти числа определяют разрешение на доступ к файлу или директории трех субъектов доступа (user,group,other). Каждое из них формируется путем суммирования восьмеричных значений необходимых разрешений:

- чтение = 4;

- запись = 2;

- выполнение =1.

Например, полный доступ (rwx) – это: 4+2+1=7


Вполне естественно, что такая простая схема, как в Minimal POSIX ACL имеет ряд недостатков. Самый явный из них, это отсутствие гибкости при совместном доступе субъектов к объектам.

Поэтому, была внедрена новая система - Extended POSIX ACL (EA) или иначе говоря расширенный список контроля доступа.

![Картинка](./Screen2.png)

Команда - **getfacl** позволяет получить информацию о настройках расширенного списка контроля доступа. Давайте проверим её работу:

```console
getfacl example1.txt
```

![Картинка](./Screen3.png)


В данном примере, стоит уточнить, будет использована машина в доменной инфраструктуре. Например, как видно по данному скриншоту group имеет значение стандартной группы для Microsoft ActiveDirectory - группа Domain Users.


Давайте попробуем установить на файл права

Шаблон применения команды:

```console
setfacl  [КЛЮЧ] [ПАРАМЕТРЫ] файл_назначения
```

Выполним её, давайте, добавим в наш файл права доступа пользователю adminsrv на чтение и запись, а также группе lpadmin добавим права на чтение и запись.

Команда звучит так:

```console
setfacl -m u:adminsrv:rw-,g:lpadmin:rw- example1.txt
```

![Картинка](./Screen4.png)

Как можно заметить, теперь в поле user и group мы наблюдаем новую информацию о правах на наш файл.

Пользователю по имени adminsrv выданы права на чтение и запись, аналогичные права также назначены на группу lpadmin.

Стоит заметить, что управление расширенным контролем доступа достаточно простое. Для работы требуется всего две команды:

- setfacl - используется для назначения, модификации и удаления ACL прав.

- getfacl - используется для просмотра установленных ACL.

Для getfacl можно применять все изученные ранее метасимволы.

Например, если вам необходимо получить список расширенного контроля доступа во всей директории можно написать:

```console
getfacl *
```

Или

Вывести все файлы с именем super* в шаблоне имени.

```console
getfacl super*
```

Также, стоит оповестить. Команда ls также отображает, что на файле расширенный список контроля доступа.

Для этого введите ls -la.

![Картинка](./Screen5.png)

Как можно заметить, теперь около стандартного набора символов, которые указывают на права доступа к файлу есть символ "+", который и указывает на применение расширенного списка контроля доступа.

Закрепим результат, создайте нового пользователя linuxuser, настройте ему максимальные права доступа
Для группы video права только на чтение.

```console
setfacl -m u:linuxuser:rw-,g:video:rw- example1.txt
```


![Картинка](./Screen6.png)

Как можно заметить, теперь в сочетании с политиками для пользователя adminsrv, права доступа также появились у пользователя linuxuser.

Напоследок, давайте закрепим в памяти основные пользовательские разрешения.

![Картинка](./Screen7.jpeg)

Отлично, разобравшись с применнием основных прав доступа через расширенные и минимальные дискреционные права, мы можем перейти к особым битам управления (SUID,SGID,Sticky-bit).


# Понимание расширенных прав SUID, GUID и sticky bit

Есть три расширенных разрешений на ваши файлы. Первое из них — это разрешение на установку идентификатора пользователя (SUID). В некоторых особых случаях вы можете применить это разрешение к исполняемым файлам. По умолчанию пользователь, запускающий исполняемый файл, запускает этот файл со своими собственными разрешениями и правами доступа.

Для обычных пользователей это SUID обычно означает, что использование программы ограничено из-за недостаточных привелегий.

Рассмотрим, ситуацию, когда пользователю необходимо сменить пароль. Для этого пользователь должен записать свой новый пароль в файл /etc/shadow. Однако этот файл недоступен для записи пользователям, не имеющим прав доступа root:


![Картинка](./Screen7.png)

**Разрешение SUID** предлагает решение этой проблемы. В утилите /usr/bin/passwd SUID настроен во всей красе! Это означает, что при смене пароля пользователь временно получает права root, что позволяет ему записывать в файл /etc/shadow. Вы можете сами увидеть разрешение SUID с **ls -l** в каталог **/usr/bin/passwd** букву **s** в позиции, где обычно вы ожидаете увидеть **x** для пользовательских разрешений:

![Картинка](./Screen8.png)

Большинству администраторов никогда не придется его использовать; вы увидите его только в некоторых файлах, где операционная система должна установить его по умолчанию.
При неправильном применении вы можете случайно раздать права доступа root, то есть администратора системы. Поэтому, подумайте заранее стоит ли вам применять такую настройку.



Второе специальное разрешение — это **идентификатор группы (SGID)**. Это разрешение имеет два эффекта:

- При применении к исполняемому файлу, он дает пользователю, который исполняет файл, разрешения владельца группы этого файла. Таким образом, SGID может выполнить примерно то же самое, что SUID, только подменять группу с её правами и возможностями. Однако для этой цели SGID практически не используется.


- При применении к каталогу, SGID может быть полезен, потому что для всех созданных подкаталогов и файлов, владелец группы будет установлен тот же, что и в "родительском" каталоге. По умолчанию, когда пользователь создает файл, его  основная группа устанавливается как владелец группы для этого файла.

(узнать основную группу можно с помощью команды **groups**, если групп несколько, то основная будет самой первой в списке)

Попробуем на простом примере объяснить возможности SGID.

Предположим, у нас есть сотрудники отдела менеджмента - Николай и Лариса. В Linux, как вы помните из базового курса, все свежесозданные пользователи попадают в одноименную с логином группу. Также, оба они добавлены в общую группу - manager.

Когда пользователь создает файл, владельцем файла является сам пользователь и первичная для него группа (то есть одноименная с ним). В таком случае, файлы которые создает Николай будут недоступны для Ларисы - и наоборот!

Однако, если мы сделаем папку - /opt/manager, применим SGID на группу manager, то получится что все созданные внутри каталога /opt/manager файлы будут иметь группу по-умолчанию manager. А значит будут доступны Николаю и Ларисе одновременно!

Разрешение SGID показывается в выводе **ls -la** как **s** в позиции, где вы обычно находите разрешение на выполнение группы:


![Картинка](./Screen9.png)


И третье из расширений - Sticky-bit. Это разрешение полезно для защиты файлов от случайного удаления в ситуации, где несколько пользователей имеют права на запись в один и тот же каталог. Если применяется  sticky bit, пользователь может удалить файл, только если он является владельцем файла или каталога.

По этой причине он применяется в качестве разрешения по умолчанию для каталога /tmp и может быть полезен также для каталогов общих групп.


Когда вы применяете sticky bit, пользователь может удалять файлы, только если выполняется одно из следующих условий:

- Пользователь является владельцем файла;

- Пользователь является владельцем каталога, в котором находится файл.


При использовании **ls -lа**, вы можете видеть sticky bit как **t** в позиции, где вы обычно видите разрешение на выполнение для других:


![Картинка](./Screen10.png)

## Применение SUID, SGID и Sticky Bit.

Для начала структурируем изученную информацию:

![Картинка](./Screen11.png)

А теперь определимся как пользоваться.
**В приведенных ниже примерах применяются только права 755 для пользователей, групп и всех остальных. Данное значение выбрано как примерное! Применять на практике вы можете с абсолютно различным сочетанием правил доступа**

Если необходимо установить SUID, выполните команду:


```console
chmod 4755 example1.txt
```

Если необходимо установить SGID, выполните команду:

```console
chmod 2755 example1.txt
```

Если необходимо установить Sticky-bit, выполните команду:

```console
chmod 1755 example1.txt
```

Проверьте с помощью **ls -la**, что вы действительно назначили данные настройки на объекты вашей файловой системы.

#А как в Linux по-умолчанию на каждый файл уже появляются какие-то права?

Вы наверняка задавали себе такой вопрос в голове.

Почему, когда вы создаете файл или каталог, то он автоматически имеет какие-то права доступа? Проверим какие?

```console
mkdir super_test
```

А затем через **ls -ld** изучим права доступа

```console
ls -ld super_test
```

![Картинка](./Screen12.png)

Получается, что на директорию были назначены права:

1) Чтение, запись и возможность входить в папку (права Execute на каталог отвечают именно за возможность входа в директорию) для владельца файла;

2) Чтение и врзможность входить в папку для группы-владельца;

3) Чтение и вход в папку для всех остальных пользователей.

А что будет, если мы создадим файл? Например, в этом же каталоге:

```console
touch super_test/file1.txt
```

![Картинка](./Screen13.png)

На файл права совершенно другие:

1) Владельцу файла позволено читать и писать;

2) Все остальные пользователи имеют право только на чтение документа.


**Это разрешения определяются настройкой под названием - umask**


В операционной системе специального назначения Astra Linux Special Edition за изменение маски прав доступа отвечает модуль pam_umask.


Модуль pam_umask пытается получить значение маски из следующих мест:

- значение umask= переданное как аргумент самому pam_umask.so

- umask= из поля GECOS пользователя

- значение UMASK=  в /etc/default/login

- значение UMASK  в  /etc/login.defs

Для активации модуля необходимо внести в конец файла /etc/pam.d/common-session строку:

```console
session optional pam_umask.so
```

Для установки глобальной маски прав доступа, можно передать параметр pam_umask.so, в том же файле /etc/pam.d/common-session:

```console
session optional pam_umask.so umask=0022
```

Или указать значение в  /etc/default/login:

```console
UMASK=002
```








































Благодарю за чтение и успехов вам в обучении!


# Дополнительная информация:
1) Шпаргалки как работать с awk [Ссылка](https://likegeeks.com/awk-command/)
2) Шпаргалки как работать с grep[Ссылка](https://digitology.tech/posts/shpargalka-po-gnu-grep/)
3) Шпаргалки как работать с sed [Ссылка](https://soft-setup.ru/shpargalka-po-sed-v-linux-s-primerami/)
