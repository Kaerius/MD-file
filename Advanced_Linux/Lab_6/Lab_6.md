# Лабораторная работа №6. Тема: "Расширенное администрирование устройств хранения данных"

Цель работы
----------
- Изучить способы cоздания и настройки логических томов,;

- Приобрести навык создания снимков состояния;

- Выполнить создание и настройку зашифрованного раздела диска.

Оборудование, ПО:
----------

Виртуальная машина или компьютер под управлением ОС AstraLinux 1.7 в режиме защищенности "Воронеж" или выше, а также с неразмеченной областью памяти на диске.

Если работаете на виртуальной машине, просто добавьте ей  два дополнительных виртуальных диска объемом, как минимум в 1 гб каждый.


Ход работы:
----------

# Начнем с терминологии и основных команд.

Данные на диске хранятся в виде файлов. Файл - это именованная область внешней памяти, в которую можно записывать и из которой можно считывать данные.

Также по ходу нашего урока мы будем использовать термин - блочное устройство.

Блочное устройство – это общий термин для обозначения устройства хранения данных, которое считывает или записывает данные в блоках определенного размера. Этот термин относится почти к каждому типу энергонезависимой памяти, в том числе к жестким дискам (HDD), твердотельным накопителям (SSD), флэш-памяти и т.д. Блочное устройство – это физическое устройство, на котором записывается файловая система. Файловая система, в свою очередь, определяет схему (разметку), согласно которой сохраняются данные и файлы.


Сами диски в системе именуются по порядку. Например, первый подключенный в систему диск через интерфейс SATA будет иметь имя - /dev/sda. Второй - /dev/sdb и так далее.

Ваши диски монтируются сразу в каталоги в операционной системе. Например, вы можете хранить всю домашнюю папку пользователя, которая по-умолчанию хранится в /home/$USERNAME сохранять на отдельном носителе.

Процесс монтирования можно выполнить с помощью команды - mount

Например,

```console
 mount -t ext4 /dev/sda /home/user
```

В этом случае ключ -t позволяет вам вручную выбрать тип файловой системы, которая установлена на диске или протокол доступа к удаленному файловому серверу (smb или nfs, например). Стоит уточнить, что команда mount  в большинстве случаев, способна сама определить тип файловой системы, особенно если монтируется локальный диск на компьютере.

Узнать список всех поддерживаемых файловых систем можно, заглянув в файл /proc/filesystems

```console
  cat /proc/filesystems
```

Монтирование с помощью команды выше выполняет это одноразово. Это удобно, когда нет необходимости в постоянно подключенном устройстве хранения. Например, при монтировании USB-накопителя или сетевого ресурса, который вы не используете постоянно.


Но что делать в случае, когда устройство необходимо постоянно?

**Помогает файл /etc/fstab**

В нем описан порядок и метод монтирования файловых ресурсов (удаленных или локальных)

Формат записи в файле /etc/fstab следующий:

**устройство точка_монтирования тип_файловой_системы опция1,опция2,опция3 дамп порядок_проверки**

Например -

**/dev/sdb1 /disk1 ext4 defaults 0 0**

Опция **defaults** как и прочие опции монтирования отразим в таблице, для удобства:


| Опции монтируемой файловой системы | Описание |
| ---------------------------------- | -------- |
| auto | файловая система монтируется автоматически |
| ro | 	монтируется в режиме "только чтение" |
| rw | монтируется в режиме "чтение и запись" |
| dev | файловая система может содержать файлы блочных и символьных устройств |
| exec | 	файловая система может содержать исполняемые файлы |
| suid | 	разрешено использование битов SUID и SGID |
| user | разрешено обычному пользователю размонтировать данную файловую систему и при этом используются значения по умолчанию (noexec, nosuid, nodev) |
| defaults | установки по умолчанию (rw, suid, dev, exec, nouser, async) |
| codepage | 	применять указанную кодировку к именам файлов |
| iocharset | отображать имена файлов в соответсвии с указанным набором символов |
| noauto | файловая система не может быть автоматически смонтирована |
| nodev	 | 	файловая система не может содержать файлы блочных и символьных устройств |
| noexec | файловая система не может содержать исполняемые файлы |
| nosuid | 	запрещено использование битов SUID и SGID |
| nouser | 	обычному пользователю запрещено размонтировать данную файловую систему |


## Попробуем отработать на практике

Проверим, какие блочные устройства есть на нашей лабораторной машине.

Воспользуемся удобной командой - lsblk

В большинстве случаев команды lsblk без каких-либо дополнительных параметров достаточно для определения диска или раздела, с которым вы хотите работать.

```console
  lsblk
```

![Картинка](./Screen1.png)

Здесь мы видим устройства, поименованные в алфавитном порядке.

**Как узнать, это SSD или жесткий диск (HDD) на Linux?**

Введите команду

```console
  lsblk --help
```

Так вы увидите список свойств, которые можно запросить у ваших блочных устройств хранения.

В этом сценарии вы будете использовать ROTA и DISC-GRAN.

ROTA сообщает вам, принадлежит ли блочное устройство к устройству ротационного хранения.

Жесткие диски являются ротационными, поэтому столбец выводит «1»  (двоичное логическое значение, означающее «true»).

DISC-GRAN показывает гранулярность сброса.

SSD поддерживают сброс, чтобы освободить неиспользуемые блоки данных.

Жесткие диски не поддерживают эту функцию, поскольку она им не нужны, поэтому в этом столбце для них будет отображаться нулевое значение («0B», что означает отказ от гранулярности нулевых байтов).

![Картинка](./Screen2.png)


**Показать файловые системы, хранящиеся на дисках / разделах**


С помощью добавления параметров FSTYPE, LABEL можно получить информацию о установленных файловых системах.

![Картинка](./Screen3.png)

**Показать съемные устройства / USB-накопители**

С помощью параметра RM, можно точно выявить где съемное устройство и его тип.

![Картинка](./Screen4.png)


Эти команды будут полезны в вашем дальнейшем администрировании.

Как вы могли заметить, на лабораторном стенде есть два блочных устройства - **/dev/sdb** и **/dev/sdc**

Исходя из выводов команд lsblk, мы сделали вывод - данные диски совершенно пустые и не имеют даже установленной файловой системы.

# Работа с разделами

Для создания разделов есть множество утилит -

От графических, например, gparted до консольных, таких как cfdisk или fdisk.

Используйте тот инструмент, который вам будет удобнее в конкретной рабочей ситуации.

Разберем консольные инструменты - fdisk и cfdisk.

## Подробнее про fdisk

fdisk - системная утилита для управления разделами жесткого диска. Встречается практически во всех операционных системах на Linux-ядре. В связи с широким распространением, с данной командой можно столкнуться на многих форумах и в документациях к проектам.

Синтаксис команды классический

```console
  fdisk опции устройство
```

например, команда ниже запустит обработку диска /dev/sdb со стандартным набором опций данной утилиты

```console
  fdisk /dev/sdb
```

Для начала, выполним команду

```console
  fdisk -l
```

![Картинка](./Screen5.png)

Данная команда покажет вам доступные для работы диски. Даже не смотря на то, что у нас с вами лабораторный стенд довольно простой, будьте внимательные при работе с разделами диска и всегда проверяйте устройства с которым вы хотите работать.

**Помните, что невнимательная работа с дисками может привести к потере полезных данных!**

Диски для нашей лабораторной работы, это **/dev/sdb** и **/dev/sdc**

Начнем с /dev/sdb


```console
  fdisk /dev/sdb
```

Попробуйте воспользоваться командой - m (manual) для того чтобы ознакомиться с справкой по команде.

![Картинка](./Screen6.png)

Ознакомившись со справкой, можно обнаружить, что команда "g" позволяет создать таблицу разделов GPT.

## Что такое таблица разделов?

**Для того чтобы разделить диск и необходима таблица разделов MBR или GPT. В этих таблицах хранятся сведения о начале и конце разделов. Даная информация помогает операционной системе определять, где начинается загрузочный диск и к какому сектору физического диска принадлежат данные**.

## Что такое MBR или GPT? В чем разница?

**На дисках с основной загрузочной записью (MBR) используется стандартная таблица разделов BIOS. Диски таблицы разделов GUID (GPT) используют единый расширяемый интерфейс встроенного ПО (UEFI).**


Создадим GPT таблицу.

![Картинка](./Screen7.png)

После этого разметим раздел на диске с помощью команды - n

![Картинка](./Screen8.png)

По умолчанию, fdisk размечает весь существующий доступны объем на диске. В нашем случае, 1 Гб.

Применим изменения с помощью команды - w

А затем сразу проверим результат через lsblk

![Картинка](./Screen9.png)

Как можно заметить, теперь у нас есть раздел объемом в 1Гб. Стоит уточнить, что файловой системы на этом разделе еще нет, а значит использовать его для хранения данных - невозможно!

Создадим файловую систему, например, с помощью встроенных в систему скриптов mkfs.

![Картинка](./Screen10.png)

Создадим EXT4 на нашем новом разделе /dev/sdb1.

![Картинка](./Screen11.png)

А теперь попробуем создать каталог в нашей операционной системе и примонтировать туда наш новый раздел.

![Картинка](./Screen12.png)

```console
  sudo mkdir /disk1
  sudo mount /dev/sdb1 /disk1
```
Перейдем в новый каталог и создадим там тестовый файл

![Картинка](./Screen13.png)

Вероятно, для создания файла в новом разделе вам потребуются права root, потому что команда mount, введеная нами выше, не дает обычному пользователю прав до данного блочного устройства.

# Fdisk неудобный?

Возможно, вам могло показаться что команда fdisk довольно неудобная. Есть ли альтернатива?

**Да, например, псевдографический cfdisk!**

Попробуем разметить диск через cfdisk на /dev/sdc

```console
  sudo cfdisk /dev/sdc
```

![Картинка](./Screen14.png)

Первым делом нам надо создать разметку GPT.

Затем выберите "Новый" для создания нового раздела.

![Картинка](./Screen15.png)

После выбора параметра "Новый" появится возможность указать размер раздела.

Также, как и консольная fdisk данная программа предлагает сразу разметить всё доступное физическое пространство диска. Выберем именно этот вариант.

![Картинка](./Screen16.png)

По умолчанию будет выбрана стандартная файловая система Linux, её мы в дальнейшем вручную настроим на ext4


Чтобы сохранить изменения выберите "Запись" в меню.

![Картинка](./Screen17.png)

И пропишите вручную - "yes"

После этого программу можно закрыть, выбрав "Выход" в меню

Проверить, что все получилось можно с помощью знакомой нам команды lsblk

![Картинка](./Screen18.png)

Установить файловую систему ext4 на разделе /dev/sdc1

```console
  sudo mkfs.ext4 /dev/sdc1
```

После этого оба наших раздела были проинициализированы и установлены, можем ими пользоваться в своих рабочих целях.


# А что еще можно делать с разделами и дисками?

Предположим, что теперь вам нужно разделить диск объемом в 1 Гб на две половины.

Безусловно, без переформатирования тут не справится, поэтому данные на дисках мы потеряем.

Попробуем!

Воспользуемся, например, тем же cfdisk.

![Картинка](./Screen19.png)

```console
  sudo cfdisk /dev/sdc
```

Удалите раздел

![Картинка](./Screen20.png)

Создатите новый раздел, и укажите его размер в 512M

![Картинка](./Screen21.png)

Если все сделали правильно, обратите внимание, что теперь на диске есть свободное пространство

![Картинка](./Screen22.png)

Для второго раздела диска оставьте все свободное пространство

![Картинка](./Screen23.png)

По итогу, получится два раздела на одном диске. Каждый из разделов по 500 Мб.

![Картинка](./Screen24.png)


## Надоело кликать по меню! А как сделать тоже самое через fdisk?

Попробуем также переформатировать наш диск /dev/sdb в два раздела.

```console
  sudo fdisk /dev/sdb
```

Далее в интерфейсе программы fdisk мы выбираем букву - d, чтобы удалить раздел.


Проверим, что раздел был удален -

![Картинка](./Screen25.png)

Создадим разделы -

![Картинка](./Screen26.png)

Команды, которые мы использовали в данном примере уже знакомы.

Из интересного:

- Мы указали номер раздела, в случае создания первого раздела номер был 1, в случае второго - 2.

- Объем диска мы указали через конструкцию - +500M (стоит сказать, что также можно и уменьшать разделы, если это поддерживается вашей файловой системой и вы предварительно сохранили данные в безопасном месте)

Проверим, что все работает командой - lsblk

```console
  sudo lsblk
```

![Картинка](./Screen27.png)

Наблюдаем два раздела по 500Мб нашего диска (в 1гб объема)

# Скучно! Где же расширенное администрирование?

Поговорим о LVM, и чем же он может пригодится вам, как системным администраторам и инженерам.

Прежде чем начать работу с LVM, разберемся - стоит ли вам использовать его.

Начнем с преимуществ.

- LVM работает на уровне ядра. Это гарантирует максимальную прозрачность конфигурации и использования диска. Приложения смогут работать с логическими виртуальными разделами LVM так же, как с обычными.

- Также в  LVM есть возможность произвольно создавать, изменять размер, переименовывать тома без перезагрузки компьютера.

- Кроме того, вы можете объединить любое количество дисков в один логический том (как в RAID, для примера), а затем создать столько томов, сколько вам нужно, быстро и легко.

- LVM позволяет создавать снепшоты логических томов без остановки операционной системы и использовать расширенные функции шифрования. Снепшоты могут быть полезны для реализации резервного копирования.


Но технология LVM имеет некоторые недостатки, которые могут быть препятствием для ее использования.

- Важнейшим недостатком является то, что LVM добавляет еще один виртуальный уровень, который может повлиять на производительность системы.

- И последним недостатком является то, что современные файловые системы (например, Btrfs и ZFS) имеют много ограничений по их использованию в производительной системе функций LVM (например, текущее изменение размера томов, создание снепшотов и т.п.). И в некоторых случаях смысл использования LVM просто теряется.

- Также, стоит уточнить, что восстанавливать LVM массивы может быть довольно сложно, что может привести к потере данных, при отсутствии резервного копирования.


## Попробуем собрать свой LVM-массив

Для начала рассмотрим схематичное изображение того, что находится внутри LVM-массива

![Картинка](./Screen28.png)

Система объединяет диски и разделы на них в единые группы, которые в дальнейшем можно монтировать






























































-  **/lib/modules/<ядро_вашей_ос>** в виде файлов с расширением "ko".

-  **/lib32/modules/<ядро_вашей_ос>** в случае, если модуль ядра для х32-битной архитектуры

-  **/lib64/modules/<ядро_вашей_ос>** в случае, если модуль ядра для х64-битной архитектуры

![Картинка](./Screen2.png)

Стоит сразу предупредить, что вам не придется искать модули ядра в разных каталогах.

Если модуль уже присутствует в каталоге /lib/modules, то в других каталогах на него будет создана символьная ссылка, для оперативного доступа и взаимодействия.

![Картинка](./Screen3.png)

Попробуем найти модули ядра, что установлены на компьютере под AstraLinux 1.7:

```console
find /lib/modules/`uname -r` -name "*.ko"
```



В следующем материале вы познакомитесь с Расширенным администрированием устройств хранения данных!

Благодарю за чтение и успехов вам в обучении!


# Дополнительная информация:
1) Руководство администратора AstraLinux Часть 1 [Ссылка](https://astralinux.ru/products/astra-linux-special-edition/relizyi/smolensk/dokumentacziya/rukovodstvo-administratora-chast-1-astra-se.pdf)
2) Про Fstab [Ссылка](https://wiki.archlinux.org/title/Fstab_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)
3) Про Fdisk [Ссылка](https://linux-faq.ru/page/komanda-fdisk)
