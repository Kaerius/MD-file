# Лабораторная работа №1. Тема: "Работа с текстовой информацией в ОС Astra Linux"
Цель работы
----------
познакомиться с функционалом регулярных выражений в утилите grep;

познакомиться редактированием текстовых потоков с помощью sed;

познакомиться с инструментом awk для составления командных строк.

Оборудование, ПО:
----------

Виртуальная машина или компьютер под управлением ОС AstraLinux 1.7 в любом уровне защищенности.

Ход работы:
----------

Умение пользоваться инструментами фильтрации и поиска текста в Linux - крайне полезный и нужный навык для инженера, который работает с данной ОС.
Не стоит полагать, что этот навык нужен только для специалистов, которые много работают с документами.
Поиск логов, создание скриптов для автоматизации, быстрые административные задачи по смене ярлыков, поиск зависшего процесса и многое другое возможно с применением этих инструментов!


Введем новый термин - **Регулярные выражения**

# Это нужно знать!

---------------

Регулярные выражения - это шаблон, который соответсвует сразу нескольким наборам строк. Шаблон состоит из операторов, используя символы и метасимволы (о метасимволах поговорим подробнее позднее)


---------------

Начнем с первого инструмента работы с текстом - утилита Grep

---------------

 **grep - утилита командной строки, которая находит строку из файлов**

---------------

Формат работы с grep следующий:

grep [ПАРАМЕТР] искомая строка [ФАЙЛ]

Начнем с простого:

```console
$  grep processor /proc/cpuinfo
```

В ответ, вам вернётся номера процессоров (каждого ядра отдельно).

Например

```console
proсessor : 0
processor : 1
```

По умолчанию, grep регистрозависимый, если запрос сформирован с прописных букв, то записи со строчными буквами отображены не будут.

Проверим, что будет если мы введем не полностью слово "processor", а например лишь его часть - слово "proc"

```console
$  grep proc /proc/cpuinfo
```

Результат тот же, значит делаем вывод - grep, при стандартном использовании без ключей, ищет строку в составе текста и слова.

А что, если нам нужно найти именно слово "proc"? Как избежать "однокоренные" значения?

Воспользуемся параметром "-w"

```console
$  grep -w "proc" /proc/cpuinfo
```

Как можно заметить, ответа не поступило! В файле /proc/cpuinfo нет строк "proc"

Давайте проверим на другом примере, выполним 'grep' на /proc/cpuinfo. Поищем слово "cpu".

```console
$  grep cpu /proc/cpuinfo
```

Как можно заметить, в этом случае, мы получили много строк, где слово "cpu" встречается отдельно, а также в составе других слов.

![Картинка](./Screen1.png)

Проверим с ключом -w

![Картинка](./Screen2.png)

Теперь, множество строк пропали, указав вам только значения конкретных слов "cpu"

А что, например, если нам нужно найти строку, которая начинается на шаблонное слово, но продолжается и оканчивается на различные символы?

Попробуем найти все строчки, которые начинаются на слово "cpu"

Обратите внимание, мы применили метасимволы. К ним относятся: ".", "\", "$", "*", "[", "]", "^", "&".

```console
$  grep 'cpu\>' /proc/cpuinfo
```

![Картинка](./Screen3.png)

А теперь, все строчки которые оканчиваются на слово "cpu"

```console
$  grep '\<cpu' /proc/cpuinfo
```

![Картинка](./Screen4.png)

А если нужное нам слово располагается в начале или конце строки?

Попробуем прописать:

```console
$  grep '^cpu' /proc/cpuinfo
```

В ответ получим строки, которые начинаются на "cpu"

![Картинка](./Screen5.png)

Проверим теперь другую конструкцию:

```console
$  grep 'cpu$' /proc/cpuinfo
```

В нашем примере файла строк, которые заканчивались на слово "cpu" - нет.

Попробуем сформировать другой запрос.

```console
$  grep 'yes$' /proc/cpuinfo
```

![Картинка](./Screen6.png)

Теперь получилось, в ответе команды получили только строки, где в конце есть слово "yes".

А если, например, задача увидеть строки рядом с искомой?

Для этого нам потребуется ключ -C. Данным ключом задается количество строк, которые нужно напечтать.
Обратите внимание, что будут показаны строки, расположенные ниже искомого значения.


Например, найдем строку расположенную ниже слова "processor"
```console
$  grep -С 1 processor /proc/cpuinfo
```

![Картинка](./Screen7.png)

Для удобства "grep" разделил найденные значения пробелом, чтобы было удобнее читать результат.

Попробуем задать значение строк побольше?

```console
$  grep -С 4 processor /proc/cpuinfo
```

![Картинка](./Screen8.png)

Стоит дополнить, что в некоторых диструбутивах вместо ключа -C используют -A (after, после).
Результат работ команды

```console
$  grep -С 4 processor /proc/cpuinfo
```

и

```console
$  grep -А 4 processor /proc/cpuinfo
```

Одинаковый.

Конечно, с помощью ключа -B (before, до) можно вывести строки выше искомого значения.

```console
$  grep -B 4 processor /proc/cpuinfo
```

![Картинка](./Screen9.png)

Будьте внимательны -  в нашем примере, строка processor = 0 является первой записью в файле /proc/cpuinfo. А значит "before" ничего не покажет.

Перейдем к серьезным регулярным выражениям. Сделаем текстовый файл со следующим содержимым:

```console
client 10.10.10.1
server 192.168.1.1
computer 127.78.245.1
router 88.11.22.33
router2 99.22.33.44
linux1 111.111.22.33
linux2 173.65.234.1
linux3 243.1.1.1
linux4 109.105.110.115
```

Первым делом, сделаем выборку по слову linux, при условии что после искомого слова есть значения от 1 до 3.

```console
$  grep "linux[1-3]" test.txt
```

![Картинка](./Screen10.png)

А если наоборот, исключая эти записи?

```console
$  grep "linux[^1-3]" test.txt
```

![Картинка](./Screen11.png)

Для понимания, определим какие метасимволы мы использовали в вышеуказанных примерах.

Метасимволы "[]" позволяют определить подмножество символов, которые необходимо распознавать при выполнении операции поиска или подстановки. Запись группы символов, заключенных в квадратные скобки, означает: "любой одиночный символ из указанных".

Метасимвол ^ (отрицание). Позволяет выполнять инверсию запроса, который вы сформировали.

Давайте дополним наш текст дополнительными строчками.

```console
client 10.10.10.1
server 192.168.1.1
computer 127.78.245.1
router 88.11.22.33
router2 99.22.33.44
linux1 111.111.22.33
linux2 173.65.234.1
linux3 243.1.1.1
linux4 109.105.110.115
New Word
Another Word
Privet
```

И выполним выборку только строк с IP-адресами.

Для этого воспльзуемся метасимволами в сочетании с опцией -E. Данная опция отвечает за поддержку расширенного регулярного выражения

```console
$  grep -E '\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b' test.txt
```

![Картинка](./Screen12.png)

Мы получили результат выборки строк, в которых у нас есть IP-адрес из 4 цифр разделенных точками (октетами). Прочие строчки, которые не имеют чисел в строке или состоят не из 4-ых значений.

Теперь, поговорим о метасимволах, которые мы применили в данном запросе.

Метасимвол \b указывает на границы искомой строки, считайте, это как способ обособления.

Метасимволы "[]" позволяют определить подмножество символов, которые необходимо распознавать при выполнении операции поиска или подстановки. Запись группы символов, заключенных в квадратные скобки, означает: "любой одиночный символ из указанных". Например, если "[0123456789]", это будет означать: "любая цифра". Можно записать и короче: "[0-9]"

Метасимвол {} позволяет определить подмножество символов, расположенных в произвольном порядке.
Понять как он работает можно на простом примере.

```console
$  touch test{1,2,3,4}
```

В ответ получим:

![Картинка](./Screen13.png)

При этом, если мы выполним аналогичную команду, но например с метасимволом [].

```console
$  touch test[1-4]
```

![Картинка](./Screen14.png)

Как видим, в этом случае []  не отрабатывает.

Применяемые далее () выполняют группировку элементов, для поиска всех совпадений по группе.
Например, можно применить так:

```console
$  grep rosatom.(lab | net | ru | com)
```

В таком случае найдено будет любое совпадение, совпадающее по запросу.

Дальнейшая конструкция позволит выполнить выбору 4 раза, для того чтобы сформировать поиск именно по 4-ых значной строке, разделенная точкой.

\.[0-9]{1,3}){3}

\. - указывает на общий разделитель.

[0-9]{1,3} - уже знакомая нам конструкция, указывает что число состоит из 3 символов.

{3} - повторяет запрос  4 раза. Потому что нумерация идет с нуля.

\b - закрывает запрос.

Таким хитрым образом, получаем выборку по IP-адресам из файла.


Следующая конструкция выполняет ту же самую процедуру, но пишется сложнее, так как не применяется такое большое множество метасимволов.

В этом примере мы явно видим разделение значений через \.,  а также описание искомых параметров.

```console
$  grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" test.txt
```

![Картинка](./Screen15.png)

А что, если есть задача вывести только адреса? Без слов рядом.

На помощь приходит ключ -o (от англ. only-matching) в этом случае, выборка будет произведена по строгому соответствию шаблону.

```console
$  grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" test.txt
```

![Картинка](./Screen16.png)

Давайте попробуем отредактировать наш test.txt, закомментируем несколько параметров.

```console
client 10.10.10.1
server 192.168.1.1
computer 127.78.245.1
router 88.11.22.33
router2 99.22.33.44
linux1 111.111.22.33
linux2 173.65.234.1
#linux3 243.1.1.1
#linux4 109.105.110.115
```

**Напомним, что в Linux символ # - является комментарием, операционная система, скрипты и различные программы игнорируют строки, которые начинаются на #. Это позволяет непосредественно в коде программы оставлять заметки или подсказки для пользователя.**

```console
$  grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" test.txt
```

Как мы видим, при вводе уже знакомой нам команды по выборке IP-адреса из текста. Она показывает нам строки, которые имеют символ #.

Предположим, что нам, как администраторам совершенно неинтересно посмотреть закомментированные (считайте неактивные) параметры.

С помощью ключа -v у команды grep можно установить инверсию запроса, то есть показать, наоборот, не подходящие строки под запрос.

А с помощью символа | (читается как - вертикальная черта, или на профеиссональном жаргоне - )

Команда выглядит вот так:

```console
$  grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" test.txt | grep -v '#'
```

![Картинка](./Screen17.png)

Наблюдаем результат, все строки, которые не имеют комментариев исключены из выдачи. Это крайне удобная функция, например, если нужно вывести все измененные значения в конфигурационном файле.

Помните, /etc/ssh/sshd_config - основной конфигурационный файл сервера SSH на вашем компьютере. Данный файл определяет настройки для подключения внешних клиентов.

В этом файле, все закомментированные строки являются значениями по умолчанию, а значит что при их изменении символ комментария '#' нужно удалять.

Команда выглядит так:

```console
$  cat /etc/ssh/sshd_config | grep -v '#'
```

![Картинка](./Screen18.png)

Попробуйте данный же файл посмотреть без grep

```console
$  cat /etc/ssh/sshd_config
```

Очевидно, что для быстрого просмотра намного удобнее анализировать файл без - '#'.

Перед тем, как перейти к теме работы с sed (потоковый текстовый редактор) стоит обратиться к тому, что так часто откладывали по ходу данной лабораторной работы.

Нам пора познакомиться  с метасимволами.


# Метасимвол . (точка)

Применение достаточно широкое, например:

При конструкции: "символ" "." "символ" означает, что между двумя искомыми символами может быть какой-то регулярный элемент.

Для эксперимента создадим файл test1.txt со следующим наполнением
```console
rea
r+a
r0a
rXa
reea
rosa
reka
```
А затем, попробуем ввести команду

```console
$  grep r.a test1.txt
```

Наблюдаем следующий вывод

```console
rea
r+a
r0a
rXa
```

Как можно заметить, мы  получили все строки, где есть слова начинающиеся на "r" и заканчивавшиеся на "a".

Попробуем поставить два символа точки, ведь у нас есть строки, которые состоят из 4-ых букв.

```console
$  grep r..a test1.txt
```

Наблюдаем следующий вывод

```console
reea
rosa
reka
```

А что будет если написать только первый символ и точку? Например так:

```console
$  grep r. test1.txt
```
В ответ получим все строчки из файла, ведь все слова начинаются на букву "r".

Дополним файл еще строками:

```console
rosenergoatom
TestWord
Linux
```

Повторим команду

```console
$  grep r. test1.txt
```

В итоге, получаем все слова которые не только начинаются на букву "r", но и содержат данную букву в своей конструкции:

```console
rea
r+a
r0a
rXa
reea
rosa
reka
rosenergoatom
TestWord
```

Слово Linux в выводе команды отсутствует, так как не содержит букву "r".
Обратите внимание, что grep в стандартном режиме работы регистрозависимый.

# Метасимвол \ (обратная дробная черта)


Обратная дробная черта (или обратный слэш) отменяет специальное значение, которое может иметь следующий за ней символ, в частности, "\." означает действительно точку, а не специсимвол - "любой символ".

Свойства обратной черты мы уже наблюдали в этой команде:

```console
$  grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" test.txt | grep -v '#'
```

# Метасимвол $ (знак доллара)

В зависимости от того, как используется знак денежной единицы ($), он может обозначать конец файла или конец строки. Когда указывается диапазон (от строки 1 до строки $), речь идет о конце файла.

Для утилиты Grep данный символ неактуальный, в отличии, например от sed.

Создадим файл example.txt со следующим содержимым, к тому же проверим как работает sed с русским языком.

```console
Это текст
Это новая строка в тестовом файле
Это третья строка в тестовом файле
Это четвертая строка в текстовом файле
Это пятая строка в текстовом файле
```

А затем выполним команду

```console
$  sed '2,$s/тестовом/текстовом' example.txt
```

Без применения ключа '-i' изменения в файл не будут внесены, а результат корректировки файла будет выведен в консоль.

![Картинка](./Screen19.png)

Разберемся подробнее в том, что сейчас произошло.

Конструкция

```console
$  sed '2,$s/тестовом/текстовом' example.txt
```

Означает, что начиная со **2** строки и до конца файла **$** выполняем замену (буква **s** сокращение от switch или substitute, то есть сменить или заменить) слово "тестовом" на "текстовом".

Проверьте, изменилось ли содержимое вашего файла с применением ключа -i.


# Метасимвол ^ (возврат каретки)

На самом деле, символ "возврат каретки" напрямую относится к историческому прошлому пищущих машинок. Он использовался после ввода строки и заставлял узел, держащий бумагу (каретку), вернуться вправо, так что машинка была готова печатать дальше на левой стороне бумаги.

В современных компьютерных системах  метасимвол "^" указывает начало строки.

Например, давайте в начало нашей строки вставим пробел.

```console
$  sed 's/^/ /' example.txt
```

![Картинка](./Screen20.png)

В примере выше указано несколько пробелов, для наглядности.


# Метасимвол * (звездочка)

В утилитах sed или grep данный метасимвол используется редко.

Но, например, пользоваться конструкцией копирования всех файлов по имени *.txt из директории

```console
$  cp *.txt /opt
```

Или удаление всех файлов, например, с именем *.txt.

```console
$  rm *.txt
```

# Метасимволы [] (квадратные скобки)

В ходе выполнения данной работы, мы уже обращались к данному метасимволу. Напомним, что он позволяет определить подмножество символов. Как целостный массив данных.

# Метасимвол & (амперсанд)

Символ &, если мы говорим про утилиты grep,sed,awk выполняют сокращение видимого текста.

Предположим, имеется строка:

```console
	В ЭТО ВРЕМЯ
```

и требуется преобразовать ее в строку:

```console
	В ЭТО ВРЕМЯ СУТОК
```
конечно, для этого можно воспользоваться командой:

```console
	s/ВРЕМЯ/ВРЕМЯ СУТОК/
```

однако требование повторно указывать слово "ВРЕМЯ" кажется неразумным. Для того, чтобы избежать этого повторения, используется символ "&". В правой части команды подстановки амперсенд означает "найденный текст", так что можно ввести команду:

```console
	s/ВРЕМЯ/& СУТОК/
```

Конечно, в данном примере экономия будет незначительной, однако если количество символов велико экономится много вводимых символов. Снижается также вероятность совершения ошибки при вводе заменяющего текста. Например, для того, чтобы заключить в скобки строку, независимо от ее длины, можно использовать команду:

```console
	s/.*/(&)/
```

Амперсенд может встречаться в правой части команды несколько раз. Команда:

```console
	s/ВРЕМЯ/& СУТОК И & ГОДА/
```
построит строку:

```console
	ВРЕМЯ СУТОК И ВРЕМЯ ГОДА
```  

а команда:

```console
	s/В ЭТО ВРЕМЯ/&? &!!!/
```  

преобразует исходную строку в:

```console
	В ЭТО ВРЕМЯ?

  В ЭТО ВРЕМЯ!!!
```  

Перейдем к практике, приведем файл example.txt к следующему формату:

```console
	ВРЕМЯ
```  

А затем протестируем указанные выше примеры:

```console
$	sed 's/ВРЕМЯ/& СУТОК' example.txt
```  

![Картинка](./Screen21.png)

Стоит уточнить, что в Bash в терминале Linux - & используется для составления больших взаимосвязанных команд, например:

```console
$	mkdir ./privet && touch ./privet/hello
```

В этом случае команда последовательно создаст директорию, а затем файл внутри неё.

Но!

Если первая команда отработает с ошибкой, то вся строка будет отменена. Удачно должны завершиться все последовательные команды.

# Что такое SED? Знакомимся подробнее.

SED – это потоковый редактор текста (от англ. stream editor), c помощью которого можно выполнять с файлами множество операций вроде поиска и замены, вставки или удаления. При этом чаще всего он используется именно для поиска и замены.

Перейдем сразу к примерам.

Подготовим файл example1.txt со следующим наполнением.

```console
 Кошка - друг человека. Кошка с давних времен помогала людям в хозяйстве. Кошка была источником вдохновения для многих произведений искусства.
```

В нашем новом тексте много повторений слова "Кошка", давайте заменим, например, на "Собака".

Воспользуемся командой:

```console
$ sed 's/Кошка/Собака/' example1.txt
```

Как можно заметить, теперь в первом предложении вместо слова "Кошка" мы видим слово "Собака".


![Картинка](./Screen22.png)

По умолчанию, sed затрагивает только первое вхождение слова из шаблона в каждой строке.

Проверим это утверждение, давайте пополним example1.txt новой строкой.

```console
 Кошка - друг человека. Кошка с давних времен помогала людям в хозяйстве. Кошка была источником вдохновения для многих произведений искусства.

 Кошка - это млекопитающее
```

Результат ниже, только первое вхождение слова изменилось в каждой строке.

![Картинка](./Screen23.png)

Хорошо, а если нам нужно изменить только второе значение из строки?

Легко:

```console
$ sed 's/Кошка/Собака/2' example1.txt
```

![Картинка](./Screen24.png)

А если третье?

```console
$ sed 's/Кошка/Собака/3' example1.txt
```

![Картинка](./Screen25.png)

Для замены всех вхождений заданного шаблона нужно воспользоваться ключом g (от англ. global - глобальный).

```console
$ sed 's/Кошка/Собака/g' example1.txt
```

![Картинка](./Screen26.png)

 Следующая команда заменит в каждой строке второе, третье, четвёртое и т.д. вхождения слова "кошка" на слово "собака":

 ```console
 $ sed 's/Кошка/Собака/2g' example1.txt
 ```

![Картинка](./Screen27.png)

Обратите внимание, что первое значение в каждой строке не изменилось.

А можно ли внести корректировки только в нужную нам строку?

```console
$ sed '3 s/Кошка/Собака/' example1.txt
```

Например, мы сменили значение только в третьей строке.

![Картинка](./Screen28.png)

Как вы можете заметить, sed по умолчанию, выводит весь правленный текст. Включая те строки, которые не были тронуты.

Предположим, что текст, с которым мы работаем крайне большой, и читать его каждый раз - затруднительный процесс.

С помощью команды:

```console
$ sed 's/Кошка/Собака/p' example1.txt
```














































# Дополнительная информация:
1) Информация о репозиториях Astra Linux [Ссылка](https://wiki.astralinux.ru/pages/viewpage.action?pageId=158598882)
2) Информация о уровнях конфиденциальности [Ссылка](https://wiki.astralinux.ru/pages/viewpage.action?pageId=27362553)
3) Подборка материалов по Системам защиты информации в Astra Linux [Ссылка](https://telegra.ph/Podborka-materialov-po-SZI-Astra-Linux-11-25)
4) Документация [Ссылка](https://wiki.astralinux.ru/pages/viewpage.action?pageId=137563555)
