# Лабораторная работа №1. Тема: "Работа с текстовой информацией в ОС Astra Linux"
Цель работы
----------
познакомиться с функционалом регулярных выражений в утилите grep;

познакомиться редактированием текстовых потоков с помощью sed;

познакомиться с инструментом awk для составления командных строк.

Оборудование, ПО:
----------

Виртуальная машина или компьютер под управлением ОС AstraLinux 1.7 в любом уровне защищенности.

Ход работы:
----------

Умение пользоваться инструментами фильтрации и поиска текста в Linux - крайне полезный и нужный навык для инженера, который работает с данной ОС.
Не стоит полагать, что этот навык нужен только для специалистов, которые много работают с документами.
Поиск логов, создание скриптов для автоматизации, быстрые административные задачи по смене ярлыков, поиск зависшего процесса и многое другое возможно с применением этих инструментов!


Введем новый термин - **Регулярные выражения**

# Это нужно знать!

---------------

Регулярные выражения - это шаблон, который соответсвует сразу нескольким наборам строк. Шаблон состоит из операторов, используя символы и метасимволы (о метасимволах поговорим подробнее позднее)


---------------

Начнем с первого инструмента работы с текстом - утилита Grep

---------------

 **grep - утилита командной строки, которая находит строку из файлов**

---------------

Формат работы с grep следующий:

grep [ПАРАМЕТР] искомая строка [ФАЙЛ]

Начнем с простого:

```console
$  grep processor /proc/cpuinfo
```

В ответ, вам вернётся номера процессоров (каждого ядра отдельно).

Например

```console
proсessor : 0
processor : 1
```

По умолчанию, grep регистрозависимый, если запрос сформирован с прописных букв, то записи со строчными буквами отображены не будут.

Проверим, что будет если мы введем не полностью слово "processor", а например лишь его часть - слово "proc"

```console
$  grep proc /proc/cpuinfo
```

Результат тот же, значит делаем вывод - grep, при стандартном использовании без ключей, ищет строку в составе текста и слова.

А что, если нам нужно найти именно слово "proc"? Как избежать "однокоренные" значения?

Воспользуемся параметром "-w"

```console
$  grep -w "proc" /proc/cpuinfo
```

Как можно заметить, ответа не поступило! В файле /proc/cpuinfo нет строк "proc"

Давайте проверим на другом примере, выполним 'grep' на /proc/cpuinfo. Поищем слово "cpu".

```console
$  grep cpu /proc/cpuinfo
```

Как можно заметить, в этом случае, мы получили много строк, где слово "cpu" встречается отдельно, а также в составе других слов.

![Картинка](./Screen1.png)

Проверим с ключом -w

![Картинка](./Screen2.png)

Теперь, множество строк пропали, указав вам только значения конкретных слов "cpu"

А что, например, если нам нужно найти строку, которая начинается на шаблонное слово, но продолжается и оканчивается на различные символы?

Попробуем найти все строчки, которые начинаются на слово "cpu"

Обратите внимание, мы применили метасимволы. К ним относятся: ".", "\", "$", "*", "[", "]", "^", "&".

```console
$  grep 'cpu\>' /proc/cpuinfo
```

![Картинка](./Screen3.png)

А теперь, все строчки которые оканчиваются на слово "cpu"

```console
$  grep '\<cpu' /proc/cpuinfo
```

![Картинка](./Screen4.png)

А если нужное нам слово располагается в начале или конце строки?

Попробуем прописать:

```console
$  grep '^cpu' /proc/cpuinfo
```

В ответ получим строки, которые начинаются на "cpu"

![Картинка](./Screen5.png)

Проверим теперь другую конструкцию:

```console
$  grep 'cpu$' /proc/cpuinfo
```

В нашем примере файла строк, которые заканчивались на слово "cpu" - нет.

Попробуем сформировать другой запрос.

```console
$  grep 'yes$' /proc/cpuinfo
```

![Картинка](./Screen6.png)

Теперь получилось, в ответе команды получили только строки, где в конце есть слово "yes".

А если, например, задача увидеть строки рядом с искомой?

Для этого нам потребуется ключ -C. Данным ключом задается количество строк, которые нужно напечтать.
Обратите внимание, что будут показаны строки, расположенные ниже искомого значения.


Например, найдем строку расположенную ниже слова "processor"
```console
$  grep -С 1 processor /proc/cpuinfo
```

![Картинка](./Screen7.png)

Для удобства "grep" разделил найденные значения пробелом, чтобы было удобнее читать результат.

Попробуем задать значение строк побольше?

```console
$  grep -С 4 processor /proc/cpuinfo
```

![Картинка](./Screen8.png)

Стоит дополнить, что в некоторых диструбутивах вместо ключа -C используют -A (after, после).
Результат работ команды

```console
$  grep -С 4 processor /proc/cpuinfo
```

и

```console
$  grep -А 4 processor /proc/cpuinfo
```

Одинаковый.

Конечно, с помощью ключа -B (before, до) можно вывести строки выше искомого значения.

```console
$  grep -B 4 processor /proc/cpuinfo
```

![Картинка](./Screen9.png)

Будьте внимательны -  в нашем примере, строка processor = 0 является первой записью в файле /proc/cpuinfo. А значит "before" ничего не покажет.

Перейдем к серьезным регулярным выражениям. Сделаем текстовый файл со следующим содержимым:

```console
client 10.10.10.1
server 192.168.1.1
computer 127.78.245.1
router 88.11.22.33
router2 99.22.33.44
linux1 111.111.22.33
linux2 173.65.234.1
linux3 243.1.1.1
linux4 109.105.110.115
```

Первым делом, сделаем выборку по слову linux, при условии что после искомого слова есть значения от 1 до 3.

```console
$  grep "linux[1-3]" test.txt
```

![Картинка](./Screen10.png)

А если наоборот, исключая эти записи?

```console
$  grep "linux[^1-3]" test.txt
```

![Картинка](./Screen11.png)

Для понимания, определим какие метасимволы мы использовали в вышеуказанных примерах.

Метасимволы "[]" позволяют определить подмножество символов, которые необходимо распознавать при выполнении операции поиска или подстановки. Запись группы символов, заключенных в квадратные скобки, означает: "любой одиночный символ из указанных".

Метасимвол ^ (отрицание). Позволяет выполнять инверсию запроса, который вы сформировали.

Давайте дополним наш текст дополнительными строчками.

```console
client 10.10.10.1
server 192.168.1.1
computer 127.78.245.1
router 88.11.22.33
router2 99.22.33.44
linux1 111.111.22.33
linux2 173.65.234.1
linux3 243.1.1.1
linux4 109.105.110.115
New Word
Another Word
Privet
```

И выполним выборку только строк с IP-адресами.

Для этого воспльзуемся метасимволами в сочетании с опцией -E. Данная опция отвечает за поддержку расширенного регулярного выражения

```console
$  grep -E '\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b' test.txt
```

![Картинка](./Screen12.png)

Мы получили результат выборки строк, в которых у нас есть IP-адрес из 4 цифр разделенных точками (октетами). Прочие строчки, которые не имеют чисел в строке или состоят не из 4-ых значений.

Теперь, поговорим о метасимволах, которые мы применили в данном запросе.

Метасимвол \b указывает на границы искомой строки, считайте, это как способ обособления.

Метасимволы "[]" позволяют определить подмножество символов, которые необходимо распознавать при выполнении операции поиска или подстановки. Запись группы символов, заключенных в квадратные скобки, означает: "любой одиночный символ из указанных". Например, если "[0123456789]", это будет означать: "любая цифра". Можно записать и короче: "[0-9]"

Метасимвол {} позволяет определить подмножество символов, расположенных в произвольном порядке.
Понять как он работает можно на простом примере.

```console
$  touch test{1,2,3,4}
```

В ответ получим:

![Картинка](./Screen13.png)

При этом, если мы выполним аналогичную команду, но например с метасимволом [].

```console
$  touch test[1-4]
```

![Картинка](./Screen14.png)

Как видим, в этом случае []  не отрабатывает.

Применяемые далее () выполняют группировку элементов, для поиска всех совпадений по группе.
Например, можно применить так:

```console
$  grep rosatom.(lab | net | ru | com)
```

В таком случае найдено будет любое совпадение, совпадающее по запросу.

Дальнейшая конструкция позволит выполнить выбору 4 раза, для того чтобы сформировать поиск именно по 4-ых значной строке, разделенная точкой.

\.[0-9]{1,3}){3}

\. - указывает на общий разделитель.

[0-9]{1,3} - уже знакомая нам конструкция, указывает что число состоит из 3 символов.

{3} - повторяет запрос  4 раза. Потому что нумерация идет с нуля.

\b - закрывает запрос.

Таким хитрым образом, получаем выборку по IP-адресам из файла.


Следующая конструкция выполняет ту же самую процедуру, но пишется сложнее, так как не применяется такое большое множество метасимволов.

В этом примере мы явно видим разделение значений через \.,  а также описание искомых параметров.

```console
$  grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" test
```






































# Метасимвол . (точка)

## Применение с утилитой Grep.



Применение достаточно широкое, например:

При конструкции: "символ" "." "символ" означает, что между двумя искомыми символами может быть какой-то регулярный элемент.

Для эксперимента создадим файл test.txt со следующим наполнением
```console
rea
r+a
r0a
rXa
reea
rosa
reka
```
А затем, попробуем ввести команду

```console
$  grep r.a test
```

Наблюдаем следующий вывод

```console
rea
r+a
r0a
rXa
```

Как можно заметить, мы  получили все строки, где есть слова начинающиеся на "r" и заканчивавшиеся на "a".

Попробуем поставить два символа точки, ведь у нас есть строки, которые состоят из 4-ых букв.

```console
$  grep r..a test
```

Наблюдаем следующий вывод

```console
reea
rosa
reka
```

А что будет если написать только первый символ и точку? Например так:

```console
$  grep r. test
```
В ответ получим все строчки из файла, ведь все слова начинаются на букву "r".

Дополним файл еще строками:

```console
rosenergoatom
TestWord
Linux
```

Повторим команду

```console
$  grep r. test
```

В итоге, получаем все слова которые не только начинаются на букву "r", но и содержат данную букву в своей конструкции:

```console
rea
r+a
r0a
rXa
reea
rosa
reka
rosenergoatom
TestWord
```

Слово Linux в выводе команды отсутствует, так как не содержит букву "r".
Обратите внимание, что grep в стандартном режиме работы регистрозависимый.







Теперь, в ответе наблюдаем только слова из 4-ых символов.

ОС Astra Linux 1.7 предназначена для применения в составе информационных (автоматизированных)
систем в цели обработки и защиты информации любой категории доступа.
В состав операциионной системы входит:

* Ядро ОС с подддержкой технлогии виртуализации;

* средства установки и настройки ОС;

* системные и сервисные утилиты;

* базовые сетевые службы;

* средства организации единого пространства пользователей (механизм, позволяющий обеспечить сквозную аутентификацию, интеграцию в доменные службы);

* программы защиты графической системы, комплексы печати;

* офисное ПО;

* И все-все, что есть в репозитории Astra Linux.


# Это нужно знать!


---------------


**Информация о репозиториях  Astra Linux x.7 (релиз 1.7 для x86_64-битной архитектур и 4.7 для ARM-архитектуры )**

# Основной репозиторий
deb https://dl.astralinux.ru/astra/stable/1.7_x86-64/repository-main/     1.7_x86-64 main contrib non-free

**Что содержит?**
Основной репозиторий AstraLinux, реализующий все функциональные возможности и параметры безопасности. Проходит сертификацию, имеет только крупные обновления.

# Оперативные обновления основного репозитория
deb https://dl.astralinux.ru/astra/stable/1.7_x86-64/repository-update/   1.7_x86-64 main contrib non-free

**Что содержит?**
Обновленный основной репозиторий AstraLinux, развивается быстрее, чем ветка main, содержит новые пакеты.  Сертифицирован.

# Базовый репозиторий
deb https://dl.astralinux.ru/astra/stable/1.7_x86-64/repository-base/     1.7_x86-64 main contrib non-free

**Что содержит?**
Все пакеты основного репозитория, пакеты с библиотеками и средства разработки ПО. В целом, зачастую для выполнения административных работ достаточно подключить только этот репозиторий. Сертифицирован.

# Расширенный репозиторий
deb https://dl.astralinux.ru/astra/stable/1.7_x86-64/repository-extended/ 1.7_x86-64 main contrib non-free

**Что содержит?**
Содержит дополнительное ПО, которое может функционировать в среде Astra Linux.
Данное ПО не дорабатывается для реализации функций безопасности и может быть несовместимо с последними оперативными обновлениями основного/базового репозиториев. Такая несовместимость фиксируется в бюллетене оперативного обновления и устраняется по мере обновления расширенного репозитория.

# Расширенный репозиторий (компонент astra-ce)
deb https://dl.astralinux.ru/astra/stable/1.7_x86-64/repository-extended/ 1.7_x86-64 astra-ce

**Что содержит?**
Содержит ПО, которое имеет возможность запускаться на AstraLinux 1.7 в режиме без поддержки политик безопасности Astra Linux. Например, Java приложения или СУБД PostgreSQL без мандатного контроля доступа. В данный момент в репозиторий входит:
  * СУБД PostgreSQL-11
  * Почтовая служба Exim4 - 4.92
  * MariaDB - 10.3
  * Java OpenJDK - 11 версии
  * LibreOffice - основная часть офисного ПО входит в репозиторий base\main, но часть пакетов LibreOffice может требовать Java для корректного отображения.
Данный репозиторий подключается следующими шагами:
в /etc/apt/sources.list или в файл c именем *.list в директории /etc/apt/sources.list.d/ добавьте строчку подключения репозитория.
Или воспользуйтесь командой:

```console
$ sudo astra-ce deb https://dl.astralinux.ru/astra/stable/1.7_x86-64/repository-extended/
```
И выполните команду переключения в режим Common Edition
```console
$ sudo astra-ce on
```

Если режим совместимости вам более не требуется, выполните команду:
```console
$ sudo astra-ce off
```

Проверить состояние совместимости ОС можно командой:
```console
$ sudo astra-ce status
```
При этом, в зависимости от текущего состояния ОС, на экран выводится сообщение:

**CE репозиторий подключен**

или

**CE репозиторий не подключен**

В дальнейшем, при оперативном обновлении системы, чтобы не заменялись пакеты, которые вы устанавливали через режим совместимости можете зафиксировать версию установленной программы командой:
```console
$ sudo apt-mark hold postgresql-11
```
---------------

# Для выполнения своих основных задач AstraLinux использует следующие модули

**Индентификация и аутентификация**

Для задачи индентификации и аутентификации используется механизм PAM (Pluggable Authentication Modules), который представляет собой набор разделяемых библиотек, с помощью которых реализуется вход пользователей в систему. Параметры входа в систему описывается через файлы в директории /etc/pam.d. Например, система контролирует Kerberos-ключи, если компьютер был введен в домен LDAP. PAM может выполнять процедуру монтирования файловых ресурсов, исходя из прав доступа пользователя, контролировать функциональные возможности пользователя в системе, организовывать систему сквозной аутентификации.


**Дискреционное управление доступом**

Решение задачи дискреционного управления доступом выполняется стандартным механизмом для Linux-систем.
В системе присутствуют индентификаторы субъектов - индентификатор пользователя (UID) и индентификатор группы (GID), имеющих доступ к сущностям (чтение, запись, исполнение). Используя данный способ можно назначать права доступа на различных файлы и директории ФС.

**Мандатное управление доступом и мандатный контроль целостности**

Для понимания механизма мандатного управления доступом определены следующие термины:
 - Субьект доступа - тот, кто выполняет операцию (например, пользователь или процесс)
 - Объект доступа - то, с чем выполняется операция, которую контролирует мандатный контроль целостности (например, файл, архив и т.д.)
 - Контейнер - сущность доступа, который состоит из множества объектов доступа внутри (например, каталог с файлами).

 Каждому объекту и контейнеру могут быть присвоены определенные мандатные атрибуты:
 * Уровень конфиденциальности - определяет степень секретности документа (файла или каталога)  и уровень доступа у пользователя, который обращается к этому файлу. Субъекту с определенным уровнем целостности разрешено читать документы с таким же уровнем целостности или ниже.
 Уровни конфиденциальности бывают (размещено в порядке возрастания конфиденциальности):
   + Не секретно
   + ДСП (для служебного пользования)
   + Секретно
   + Совершенно секретно
Данный механизм называется "Модель безопасности Белла-ЛаПадулы".

Её визуализация представлена на рисунке ниже.

 ![Картинка](./Rules1.png)

Как можно заметить, система несовершенна и имеет ряд недостатков.
С целью сделать её более гибкой, в AstraLinux внедрена система категорий конфиденциальности.

Постараемся привести  пример данной модели, из документа "Руководство по КСЗ. Часть 1 РУСБ.10015-01 97 01-1".

Представим, что у нас есть две категории "Яблоки" и "Апельсины". Мы наделили персонал, с уровнем доступа Секретно, полномочиями работать только с документами категории "Яблоки". Обращаться к документами категории "Апельсины", с тем же уровнем доступа "Секретно", данный персонал не сможет, ровно также как и передавать данные о документах "Яблоки" тем пользователям, кто работает с "Апельсинами". При этом, вероятно нам нужно дать универсальный доступ пользователю "Начальник", который может работать с документами любых категорий.

Итак, с помощью параметров  уровень конфиденциальности и категории конфиденциальности AstraLinux обеспечивает защиту от несанкционированной передачи информации:

* Невозможность прочитать информацию, к которой не предоставлен доступ:
- "нижним" уровням запрещено читать информацию с "верхних" уровней;
- всем запрещено читать информацию, на которую нет разрешенной категории конфиденциальности;
* Невозможность  передать информацию тому, кому не предоставлен доступ:
- "верхним" уровням запрещено записывать свою информацию на "нижние" уровни;
- всем запрещено передавать информацию тем, у кого нет соответствующей категории конфиденциальности.

**Целостность**

Атрибут Целостности в AstraLinux был применен на основе аналогичной модели 2007 года - MIC (Mandatory Integrity Control) всех ОС семейства Microsoft.

В общем, требование защиты целостности выглядит так:

**Субъект (процесс или пользователь), работающий на некотором уровне целостности, может записывать (изменять) только сущности (объекты) своего, или более низкого уровня (запись "вверх" запрещена).**

Чем-то похоже на уже описанный выше механизм уровней целостности, правда?

Основное отличие лишь в сфере применения. Атрибут целостности в AstraLinux призван защищать не информацию, хранимую на этом компьютере, а вычислительную машину в целом и её внутренние компоненты.

Классификацию уровней целостности легко представить в виде таблицы.

| Порядковый номер | Значение | Битовая маска | Комментарий
| -----------------| -------- | ------------- | -----------
| 0  | 000 | 0000 0000 | Нулевой уровень. "Низкий" |
| 1  | 001 | 0000 0001 | Уровень для сетевых сервисов |
| 2  | 002 | 0000 0010 | Уровень для Виртуализации |
| 3  | 004 | 0000 0100 | Уровень для специального ПО |
| 4  | 008 | 0000 1000 | Уровень графического сервера |
| 5  | 016 | 0001 0000 | По-умолчанию свободен, может быть использован для СУБД |
| 6  | 032 | 0010 0000 | Свободен |
| 7  | 064 | 0100 0000 | Высокй уровень. Уровень администратора |
| 8  | 128 | 1000 0000 | Высокй уровень. Уровень администратора в системах виртуалиации Брест |

**Внедрение ЭЦП**

Инструменты замкнутой программной среды позволяют использовать в AstraLinux  ЭЦП - электронную цифровую подпись.
В ядро Linux, применяемое в данном дистрибутиве, реализован модуль ядра digsig_verif, который поддерживает функционал загрузки, чтения и аутентификации в информационных системах черех ЭЦП (RuToken, Jacarta и т.п.)

**Системные ограничения и блокировки**

В операционной системе есть механизм блокировки действий пользователя. Основные настройки:
- Запрет установки ключа (бита) исполнения;
- блокировка консоли для пользователей;
- блокировка интерпретаторов;
- блокировка макросов;
- блокировка strace и ptrace;

Полный перечень ограничивающих функций безопасности и их описание приведены в РУСБ.10015-01 97 01-1.

**Фильтрация сетевого трафика**

В ОС AstraLinux в качестве межсетевого экрана используется UFW, с поддержкой следующего функционала:
- Фильтрация входящего и исходящего трафика
- Работа с протоколами IPv4 и IPv6
- Журналирование трафика
- NAT
- Маркировка трафика
- Приоретизация трафика, лимиты

**Виртуализация**

AstraLinux 1.7 поддерживает виртуализацию KVM.
Также возможно развернуть систему виртуализации Брест, в составе OpenNebula + KVM.


На этом первая работа из расширенного курса AstraLinux завершена.
Приступим к практической работе **Работа с текстовой информацией в ОС Astra Linux**



# Дополнительная информация:
1) Информация о репозиториях Astra Linux [Ссылка](https://wiki.astralinux.ru/pages/viewpage.action?pageId=158598882)
2) Информация о уровнях конфиденциальности [Ссылка](https://wiki.astralinux.ru/pages/viewpage.action?pageId=27362553)
3) Подборка материалов по Системам защиты информации в Astra Linux [Ссылка](https://telegra.ph/Podborka-materialov-po-SZI-Astra-Linux-11-25)
4) Документация [Ссылка](https://wiki.astralinux.ru/pages/viewpage.action?pageId=137563555)
